# Testing Guidelines Template

This document outlines how to set up, run, and maintain tests for [Project Name] across unit, security, and integration types. Tests ensure code integrity, security, and full-system functionality before sprint completion. Agents must follow these rules: Run tests after every code change; fix failures before committing; update docs/tests if code changes. Do not edit this file without explicit user instruction—reference it strictly.

## Guidelines for Filling Out This Template
- Replace [Project Name] with your project's name.
- Customize test types/locations to match your tech stack (e.g., for Python: pytest for unit; for JS: Jasmine).
- Adapt tools/setup to your languages (e.g., Python: `pip install pytest`; Rust: `cargo test`).
- Tailor sprint-end checks and fixing steps to your workflow (e.g., add CI/CD integration if used).
- Add project-specific examples (e.g., "Test wallet signing" for blockchain projects).
- Reference repo structure: Store this in /docs/agents/testing_guidelines.md; link to /file_structure.md for test locations in /tests/.

## Test Types and Locations
Tests live in `/tests/`, run via `/scripts/test-suite.sh`. Each type has a purpose:

- **Unit Tests** (`/tests/unit/`): Test individual functions/modules (e.g., [language-specific example: Python functions, Rust zomes]). Use [tool: e.g., pytest for Python, Jasmine for JS, cargo test for Rust].
- **Security Tests** (`/tests/security/`): Scan for vulnerabilities (e.g., injection risks, auth checks). Use tools like [tool: e.g., bandit/safety for Python, cargo-audit for Rust, ESLint-plugin-security for JS].
- **Integration Tests** (`/tests/integration/`): End-to-end tests launching the full app (e.g., [project-specific: API endpoints, PWA + backend]). Use [tool: e.g., Playwright for e2e, hc test for Holochain].

## Setup
1. Install deps: Run `/scripts/setup.sh` (includes [tools: e.g., pytest, Playwright, cargo-audit]).
2. For sprints: At sprint start, review Implementation Plan tasks; create test stubs in relevant folders (e.g., `unit/renderer.test.py` for rendering tasks).
3. Run all: `./scripts/test-suite.sh` (runs unit first, then security, then integration).

## Running Tests
- **Unit**: [command: e.g., `pytest tests/unit` or `cargo test` in `/source/[relevant-dir]`].
- **Security**: [command: e.g., `pytest tests/security` or `cargo audit` for Rust].
- **Integration**: [command: e.g., `pytest tests/integration` (launches app, simulates inputs)].
- **Sprint-End Check**: All must pass 100% before merge; log failures in `/docs/tests/unit.md` (e.g., "[test].test.py failed on [function]—fixed by [reason]").

## Fixing and Maintaining
- On failure: Debug with [tools: e.g., console.log or browser dev tools]; update code, re-run.
- For sprints: Add 1-2 tests per task (e.g., Sprint 1: test player movement bounds).
- Update docs: After fixes, edit `/docs/tests/unit.md` with Mermaid flow (e.g., test sequence diagram).

Agents: Always run tests before committing. Reference Backend Structure for data integrity tests (e.g., sync checks).